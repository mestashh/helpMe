Ключевой механизм вывода в графах знаний – это онтологический вывод, или reasoning на основе онтологий (аксиом, деклараций классов и свойств). Онтология, описанная на языках RDFS/OWL, сама по себе содержит знания о взаимосвязях понятий,
которые могут использоваться для вывода новых фактов из существующих. Вывод на основе онтологии означает, что система автоматически извлекает неявные следствия, заложенные в онтологии, применяя их к имеющимся данным.
Наследование классов: если онтология содержит А rdfs:subClassOf B (A – подкласс B), а в данных есть факт x rdf:type A (x принадлежит классу А), 
то вывод: x rdf:type B (x принадлежит также классу B). Это следует из семантики субклассов: каждый экземпляр подкласса является экземпляром суперкласса.
Наследование свойств: если p rdfs:subPropertyOf q, и есть a p b, то можно вывести a q b.
Онтологический вывод выполняется специальными программами – OWL-резонерами. Алгоритмы зачастую основаны на приведении логических формул к каноническому виду и проверке выполнимости (для OWL DL – алгоритмы Tableaux). Но результат для пользователя – reasoner может:
Выявить новую принадлежность классу (class membership).
Построить иерархию подклассов (class hierarchy) с учетом скрытых отношений. Например, если онтология утверждает что А ⊆ B, B ⊆ C, reasoner явно выстроит цепочку A–C (и может вывести A ⊆ C транзитивно).
Пример конкретного вывода:
Онтология:
ex:Man rdfs:subClassOf ex:Person.
ex:Woman rdfs:subClassOf ex:Person.
ex:Man owl:disjointWith ex:Woman.
ex:hasMother rdfs:domain ex:Person; rdfs:range ex:Woman.
Данные:
ex:John ex:hasMother ex:Mary.
ex:John rdf:type ex:Man.
Вывод:
Из hasMother domain Person и тройки John hasMother Mary -> John rdf:type Person.
Но John уже типа Man, а Man – подкласс Person, так что согласуется.
Из hasMother range Woman и той же тройки -> Mary rdf:type Woman.
Reasoner знает Woman и Man disjoint. Если бы где-то Mary rdf:type Man было, он бы сигнализировал ошибку.
Из Man subClassOf Person, John rdf:type Man -> уже имеется John rdf:type Person (можно проверить, reasoner бы вывел, если не было).
Если теперь задать запрос «является ли Mary Person?», то: Mary тип Woman, а Woman подкласс Person (если задано аналогично Man), тогда reasoner тоже выведет Mary rdf:type Person. То есть становится известно, что Mary – Person, хотя явно не было.
Как видно, многие новые утверждения могут быть получены: John – Person, Mary – Person, Mary – Woman. Это и есть обогащение графа знаний за счет онтологии.
Подводя итог: онтологический вывод автоматически делает эксплицитным то, что имплицитно содержалось в логических определениях онтологии. Это позволяет:
Автоматически классифицировать объекты (разнести индивиды по классам, где они должны состоять).
Распространить свойства и отношения по иерархиям (наследование).
Контролировать качество данных (нахождение противоречий).
Отвечать на более общие запросы. Например, запрос «найти всех Person, связанных свойством hasChild с Alice» вернет и тех, кто напрямую Person, и тех, кто были помечены только как Man или Woman (subclasses of Person) – если reasoner добавил тип Person,
либо если SPARQL endpoint сам учитывает subClassOf (некоторые могут, но надежнее материализовать).
