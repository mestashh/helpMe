Логический вывод (reasoning) в графах знаний – процесс получения новых знаний (триплетов, утверждений) из существующих, на основании заложенных в систему правил и онтологических аксиом.
Один из подходов – вывод на основе правил (rule-based reasoning), когда знания выводятся с помощью явно заданных правил типа «если ... то ...». В контексте семантических технологий такие правила могут быть выражены на специальных языках (например, SWRL, SHACL-SPARQL, RuleML/RIF)
или реализованы программно (например, через движок правил Jena или встроенные механизмы триплсторов). Правила вывода представляются в виде шаблонов, сопоставляемых с графом знаний. Типичное правило имеет вид: Antecedent ⇒ Consequent (ЕСЛИ условие, ТО утверждение).
Условие и вывод состоят из одного или нескольких атомарных высказываний о связях между сущностями. Например, простое правило:
«Если X является родителем Y, а Y является родителем Z, то X является дедушкой/бабушкой Z». Запишем это в неформальной нотации:
IF   Parent(X, Y) AND Parent(Y, Z)  
THEN Grandparent(X, Z).
Такое правило позволяет выводить новое отношение Grandparent на основании двух имеющихся отношений Parent. Ни OWL, ни RDFS напрямую не выражают подобное (OWL может частично через property chain, но в общем случае нужны правила).
Пример языка правил – SWRL (Semantic Web Rule Language): SWRL расширяет OWL и позволяет писать правила с использованием предикатов, привязанных к онтологии. Синтаксис SWRL прост: в левой части (body) – конъюнкция атомов,
в правой (head) – тоже конъюнкция (часто из одного атома). Правило применяется, если в данных найдены соответствия, подставляющие конкретные индивиды под переменные так, что все атомы body истинны; тогда можно добавить атомы head. Например, правило для дедушки:
Person(?x) ^ Person(?y) ^ Person(?z) ^ hasChild(?x, ?y) ^ hasChild(?y, ?z) -> hasGrandchild(?x, ?z)
Здесь ?x, ?y, ?z – переменные; ^ обозначает AND; предикаты hasChild и классы Person – из онтологии. Это означает: если ?x, ?y, ?z – люди и ?x является родителем ?y, а ?y – родителем ?z, то ?x имеет внука ?z (считаем hasGrandchild транзитивным сводом hasChild).
SWRL-правило, будучи добавленным в систему, позволяет reasoner'у с поддержкой SWRL дедуцировать триплет ?x hasGrandchild ?z когда встречается нужная комбинация фактов.
Синтаксис правил можно изложить и иначе; важно, что у правила есть условие (левая часть) и следствие (правая часть), и оно применяется ко всем подходящим к условию набором сущностей в графе. Условие считается истинным, если все его атомы найдены в данных;
если хотя бы один атом не находит соответствия – правило не срабатывает. В этом смысле механизм правил – аналог логических продукций или Datalog-запросов.

Применение правил в графе знаний:
Правила позволяют выразить отношения и ограничения, которые не удалось смоделировать чисто онтологически. Например, правило для симметричного свойства (если X связан с Y по R, то Y с X по R)
можно заменить OWL-аксиомой SymmetricProperty. Но более сложное правило – «если человек работает в организации, а организация расположена в стране, то можно связать человека с той страной (работает_в_стране)» – проще описать правилом:
worksAt(?person, ?org) ^ locatedIn(?org, ?country) -> worksInCountry(?person, ?country).

Недостатки/ограничения:
Нужно аккуратно составлять правила, чтобы не было бесконечных циклов (например, правило A->B и B->A может порождать бесконечный вывод)
Правила могут выводить факты, которые нарушат онтологические ограничения, если такие есть (т.е. reasoner обнаружит несоответствие).
